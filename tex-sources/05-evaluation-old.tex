\section{Evaluation}
\label{sec:Eval}

We focus our evaluation on the effect of tighter upper bounds on different workloads, with special attention to the Join Order Benchmark. All experiments are conducted using our \emph{PostBOUND} framework with different optimization settings. 

We focus our evaluation on the influence of the thighter upper bounds on different workloads, with a focus on the Join Order Benchmark (\TODO{cite}). All experiments are conducted using the \emph{PostBOUND} framework with different optimization settings. Each experiment workload is repeated for a total of 5 times and for each query in the workload the best (i.e. fastest) repetition is selected. When upper bounds are calculated using Top-k lists, we limit the resulting bound by the corresponding UES bound. This way we ensure that the upper bounds do not become needlessly large if a smaller bound is known. The experiments are executed on an Ubuntu 20.04 system running PostgreSQL 14.2 and Python 3.8. It contains an Intel i7-6700 HQ processor, 32 GB of main memory and an SSD storage.

\subsection{Evaluation on the Join Order Benchmark}
\label{sec:eval-job}

Facing the Join Order Benchmark, \emph{PostBOUND} is configured to ``precise'' statistics, i.e. instead of relying on the Postgres-internal statistics, \emph{PostBOUND} issues equivalent queries that emulate the information and contain the correct answer. For example, instead of fetching the most common values from \sql{pg\_stats}, a \sql{COUNT(*)} query with a \sql{GROUP BY} and \sql{LIMIT} clause is executed. This strategy has two nice properties: First up, optimization becomes much more reproducible because different \sql{pg\_stats} tables do not influence the result. Secondly, metadata becomes reliable because its exact nature can be controlled. This is in contrast to for example the most frequent values managed by Postgres, since these lists are constructed on the fly as Postgres sees fit and cannot be maintained manually.

Using these basic settings, we examine how much upper bounds can be improved using the Top-k based formulas and we analyze how this influences the workload performance. In order to do so, we optimize the JOB workload queries with both the cautious Top-k formula and the approximate Top-k formula, based on different lengths of the Top-k lists. More specifically, the cautious formula receives lists of lengths 1 to 5 and uses the ``smart'' subquery generation strategy (see Section~\ref{item:postbound-subqueries}). The approximate formula receives lists of lengths 1, 5, 10, 20, 50, 100 and 500 and uses both the linear as well as the ``smart'' subquery generation strategy. These settings are chosen because the optimization time of the cautious formula in its canonical form is too long for larger values of $k$. On the other hand, the approximate formula operates differently and can therefore be used to explore the behaviour for rather long Top-k lists.

\begin{figure}[tb]
	\centering
	\begin{subfigure}[b]{0.47\textwidth}
	    \centering
	    \includegraphics[width=\textwidth]{figures/plot-job-runtimes-topk-cautious.pdf}
	    \caption{Total runtime.}
	    \label{fig:results-job-runtimes-cautious}
	\end{subfigure}
	\begin{subfigure}[b]{0.47\textwidth}
	    \centering
	    \includegraphics[width=\textwidth]{figures/plot-job-mean-bounds-topk-cautious.pdf}
	    \caption{Mean upper bounds of the optimized queries.}
	    \label{fig:results-job-bounds-cautious}
	\end{subfigure}
	\caption{JOB queries optimized by the cautious Top-k formula.}
	\label{fig:results-job-cautious}
\end{figure}

Comparing the total workload runtime of the cautious Top-k settings to the runtime of UES (cf. Figure~\ref{fig:results-job-runtimes-cautious}) shows no significant deviation. In fact, minimum and maximum runtimes differ by less than 10 seconds. Still, the cautious formula tightens the upper bound by a factor of up to about $1/3$ (cf. Figure~\ref{fig:results-job-bounds-cautious}) when comparing the mean bounds. This reduction however does only lead to 5 updated queries in total compared to the join orders determined by UES (1 at Top-4 and the remaining 4 at Top-5). The maximum runtime change caused by these updates affects query 7c with an absolute speedup from 10 seconds to 9 seconds. We therefore conclude that using short Top-k lists with the cautious formula does not lead to a noteworthy improvement compared to a plain UES setup.

\begin{figure}[tb]
	\centering
	\begin{subfigure}[b]{0.47\textwidth}
	    \centering
	    \includegraphics[width=\textwidth]{figures/plot-job-runtimes-topk-approx.pdf}
	    \caption{Total runtime.}
	    \label{fig:results-job-runtimes-approx}
	\end{subfigure}
	\begin{subfigure}[b]{0.47\textwidth}
	    \centering
	    \includegraphics[width=\textwidth]{figures/plot-job-box-bounds-topk-approx.pdf}
	    \caption{Mean upper bounds of the optimized queries.}
	    \label{fig:results-job-bounds-approx}
	\end{subfigure}
	\caption{JOB queries optimized by the approximate Top-k formula.}
	\label{fig:results-job-approx}
\end{figure}

For the approximate Top-k formula, the runtime (cf. Figure~\ref{fig:results-job-runtimes-approx}) again closely matches the performance of  the most frequent value-driven bounds. For this formula, we also analyze the linear subquery generation strategy (which never generates any subqueries), since this setting only allows variation in the join order and is therefore easier to compare to the UES measurements. Nevertheless using the Top-k based formulas does not have much impact on the total runtime. In fact, the runtime variation becomes even less with about 5 seconds for both linear and ``smart'' workload. On the other hand, the more aggressive nature of the approximate formula improves the mean upper bound by a factor of 490. However, longer Top-k lists do not necessarily imply tighter bounds (cf. Figure~\ref{fig:results-job-bounds-approx}): Despite that queries tend to have better upper bounds overall, some outliers exist. These are caused by large base tables that are heavily filtered, since a Top-k list does not know about the influence of a filter predicate on its most frequent values. For example, consider a Top-3 list with the following frequencies: $(100, 90, 80)$. If the corresponding base table is estimated to only contain 5 tuples after filtering, the Top-k list does not have any information about how these tuples are allocated. Therefore, it can only reduce the individual frequencies, resulting in the Top-k list $(5, 5, 5)$. Still, these add up to 15 tuples in total, i.e. an overestimation of 200\%. In the end, much more tuples are processed, than are actually available. As the Top-k lists become longer, this effect becomes worse. This phenomenon was one of the major motivations for creating the cautious formula in the first place (cf. Section~\ref{sec:TighterBounds}).

\begin{figure}[tb]
    \centering
    \includegraphics[width=\linewidth]{figures/plot-job-line-bounds-top50-approx.pdf}
    \caption{Upper of the approximate Top-50 formula compared with UES and the true cardinality.}
    \label{fig:results-job-approx-bound-comparison}
\end{figure}

Looking at the overall bound distribution (cf. Figure~\ref{fig:results-job-bounds-approx}), the Top-50 workload seems to be the best instance among the evaluated candidates as it does not contain outliers while still reducing the overall bound. Therefore, we base the remainder of the approximate formula analysis on this workload. Compared to the cautious formula, the tighter bound causes much more updates in the join path. In total, 31 queries are updated. Still, these updates only cause a maximum runtime difference of 4 seconds and the majority change the runtime by less than 1 second. Since none of these changes are significant, we take a closer look at the relation between the bounds on a per-query basis next. Figure~\ref{fig:results-job-approx-bound-comparison} shows the UES bound along with the true cardinality for each Top-50 optimized query. This exhibits no clear pattern and the bounds are largely uncorrelated. Most importantly, a \emph{tighter} bound does not indicate an actually \emph{tight} bound as it can still overestimate the true cardinality by a large margin. Since join orders are quite robust once their overall relation is determined\footnote{as long as the relative order between tables stays the same, it does not matter if a bound overestimates by a factor of 10, 100 or 1,000}, the approximate formula does not get close enough to the true cardinality to change the join order in a significant way and plain UES once again is sufficient for this task. However, the large improvement of the upper bound for some queries (up to a factor of 69,000) hints at the potential of Top-k based upper bounds for other tasks, such as operator choice.

In terms of optimization time, the approximate formula is much faster with a maximum runtime of about 3.7 seconds for Top-500 compared to the 72 seconds for Top-5 when using the cautious formula. This aligns with the general findings of Section~\ref{sec:TighterBounds} since the cautious algorithm is much more complex. A number of optimizations would be required to apply this algorithm in a more practical setting (i.e. with larger Top-k lists).

To summarize, upper bounds based on Top-k lists seem to have little influence on the overall join order and simpler approaches such as UES work fine in this situation. However, the potential of Top-k lists to significantly reduce the upper bounds could make them viable for other tasks, most importantly physical operator selection, since their margin of error is much smaller.

\subsection{Evaluation on the Star Schema Benchmark}
\label{sec:eval-ssb}

In addition to the Join Order Benchmark, we also apply \emph{PostBOUND} to the Star Schema Benchmark based on TPC-H. However, the workload here focuses mainly on a proof-of-concept of the applicability of \emph{PostBOUND} to different databases and its independence from specific workloads. Therefore, we use a small scale factor of 0.5 for the database and only execute two different \emph{PostBOUND} settings. The first one uses the UES bound formula, while the second one is based on Top-15 lists for the approximate Top-k formula. Both settings use the Postgres optimizer to obtain cardinality estimates for base tables and generate subqueries for primary key/foreign key joins as soon as an improvement of the overall bound is guaranteed. These optimization settings are chosen in order to test strategies that have not already been used for the Join Order Benchmark.

\begin{figure}[tb]
	\centering
	\begin{subfigure}[b]{0.47\textwidth}
	    \centering
	    \includegraphics[width=\textwidth]{figures/plot-ssb-runtimes.pdf}
	    \caption{Total runtime.}
	    \label{fig:results-ssb-runtimes}
	\end{subfigure}
	\begin{subfigure}[b]{0.47\textwidth}
	    \centering
	    \includegraphics[width=\textwidth]{figures/plot-ssb-bounds.pdf}
	    \caption{Upper bounds.}
	    \label{fig:results-ssb-bounds}
	\end{subfigure}
	\caption{SSB queries optimized by the approximate Top-k formula.}
	\label{fig:results-ssb}
\end{figure}

Figure~\ref{fig:results-ssb} shows the runtime of the different settings along with the upper bounds calculated by \emph{PostBOUND}. Once again, there is no significant deviation. However, due to the small scale factor all queries run very quick which in turn makes the measurements more fragile and also strais away from the focus on heavy hitters for pessimistic optimization algorithms. The upper bounds of UES and the Top-15 formula line up exactly in this setting, which is due to imprecise base table estimates. This results in UES calculating slightly better bounds for this workload, which in turn triggers the final maximum operator in the Top-k bound formula and pushes the bound down to the UES value. Using the precise base table estimates gives a slight edge to the Top-k formula again (about 1\% tighter bounds).
